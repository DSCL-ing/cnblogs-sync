# 希尔排序

## 概述

希尔排序，也称**递减增量排序**算法,也称**缩小增量排序**，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是**基于插入排序**的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

插入排序主要性能浪费在挪动上,坏情况下需要每次插入都要挪动多次.

希尔排序将整体有序化,大大减小每轮挪动的次数.

希尔排序依旧有挪动的性能浪费,只是概率减小

**小规模数据优化**：对于小规模的数据集，希尔排序可能比其他算法更快，因为其时间复杂度接近线性。因此希尔/插入排序可以在其他排序过程中,取代"合并有序"的部分,以提高效率.





## 算法步骤

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

按增量序列个数 k，对序列进行 k 趟排序；

每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。







## 代码实现

>  注:以升序举例,排序数组为a[n]



算法来源:

优化直接插入排序,结合直接插入特性,先整体有序(相对),再局部有序,充分发挥插入排序特性.



算法思想:

前n-1个有序数组,第n个为待排序(插入)元素,通过插入让第n个待排序数组也有序.



具体状态:

1. `a[n-1]<a[n]` ,有序

2. 至少存在`a[n] < a[0],a[1],...,a[n-1]`,需要排序

   其中边界为`an[n]<a[0]`

3. `n == 1`:边界

   一个一定是有序的



满足稳定排序写法:

`a[n]<a[n-1]`时才插入(小于才插入)

不稳定排序写法:

`a[n]<=a[n-1]`时插入(相等时也交换)



插入排序特征:

- 迭代范围:从小到大

- 插入过程范围:从大到小

- 插入过程:挪动覆盖

```
void ShellSort(int *a, int n)
{
	int gap = n ;
		while (gap > 1)
	{ 
			//gap /= 2;
			gap = gap/3+1;
		for (int i = 0; i < n - gap; i += 1)  //n个数排列，只需排n-1个，（因为第一个必定有序--默认）
		{
			/*第一个数排序*/
			int end = i;  //下标 ， 已排序数组【0 - end】
			int tmp = a[end + gap];  //要插入的数

			//一个元素排序，排一个数(先假想出一堆乱序数组)
			while (end >= 0)
			{
				/*挪动一次*/
				if (a[end] > tmp)
				{
					a[end + gap] = a[end]; //往后挪动
					end -= gap;   //比下一个元素
				}
				else
				{
					break; //插入
				}
			}
			a[end + gap] = tmp; //插在end后面
		}
	}
}
```

