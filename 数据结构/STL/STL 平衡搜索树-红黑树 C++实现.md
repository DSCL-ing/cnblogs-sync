[toc]

# 红黑树

## 基本概念



规则

- 根节点是黑色.
- 任意两个相邻结点**不能同时为红**.即红色结点的孩子是黑色的.(不能出现连续的红色结点)
- 任意结点到其可到达的叶节点间,均包含**相同数量的黑色结点**.(每条路径上都有相同的黑色结点)

> 基础规则:每个结点不是红色就是黑色
>
> 推导规则:
>
> - **一条路径**的所有可能情况中,最长路径节点个数不会超过最短路径的两倍(连续的红节点能够使最长路径超过最短路径的两倍)
>
>   > 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
>
> - 红色结点如果有两个孩子,则都是黑色.
>
> - 修改祖先结点颜色变化不会影响所有分支路径的黑色结点的平衡(修正常用)
>
> 补充:叶结点都是黑色,且不存数据,也被称为NIL结点[nil（计算机语言）_百度百科 (baidu.com)](https://baike.baidu.com/item/nil/4074055?fr=ge_ala)
>
> 转载:通过将红黑树的所有叶子节点都替换为NIL节点，可以保证红黑树的每个节点都至少有一个子节点，从而简化了操作的实现。NIL节点的存在有助于维护红黑树的结构和性质，特别是在处理边界情况时，通过判断节点的子节点是否为NIL节点来避免特殊处理叶子节点的情况.



推导规则

- 最短路径:全部是黑色结点
- 最长路径:红黑相间(一黑一红,**最后一个非NIL结点可以是红**)

- 去掉红色结点的红黑树接近一棵满二叉树.(直接去掉红色结点可能就不是二叉树了,hold不住)
- 当只有一个根节点时(黑),第二个结点只能是红色(满足黑结点数量相同),被迫只能插入红色结点.

- 新增结点默认为红色,红色规则比黑色宽松



推导

设黑色结点有N个

- 最短路径长度为:$log_2(N) $

- 最长路径长度为:$2log_2(N)$

- 一棵红黑树的所有结点数量在**[N,2N]**之间.(全黑为N,红黑全满为2N)
- 性能上,假设有10亿个结点,AVL树最多查找30次, RB树最多查找60次





> 注:文章仅以理解红黑树的主要功能(插入修正)实现为主,没有实现对NIL结点处理等其他情况,不是严谨的红黑树实现.





变色:

只有父亲是红色时,才需要变色,且必须变色.(红节点不相邻规则)

变色的基础:插入红节点规则最宽松,不需要调整其他路径,因此插入结点不可变色,所以只能将**父亲变成黑色**,后面就围绕父亲变黑后,爷爷结点和叔叔结点如何变色进行处理.

> 一句话:父亲是红色时,必须要变色,且变色的是父亲.(扩展说法:都是父爷颜色交换.后文详细解释)



叔叔是红色

即叔叔和父亲都是红色,即叔叔和父亲都是非NIL结点的最远结点.

>  反证:如果叔叔还有子结点,那一定是黑色,即多了一个黑色结点;为了满足各路径黑结点数量相同的规则,父结点也必须要有黑色子节点,且必须要有两个,那就无法再插入新节点了,因此这种情况不可能.

左左(LL型):父变黑,爷变红(父爷交换颜色),叔叔变黑.

> 感性解释:
>
>   父子都是红,只能且必须由父亲变黑.因为多了一个黑结点,所以所在路径必须上少一个黑结点;
>
>   要少哪一个呢?肯定不能往下了,因为下面是已经处理过了(修正操作是往上迭代的),所以只能往上寻找;
>
>   因为插入前路径上的所有结点都是满足红黑树规则的,所以爷爷结点一定是黑色;又因为爷爷距离父是最近的结点,对其他结点影响最小,因此选择将爷爷结点置为红,即将父爷结点颜色交换;
>
>   爷爷颜色是红色结点后,叔叔路径则少了一个黑色结点,因此叔叔结点必须变黑.

左右(LR型):父变黑,爷变红(父爷交换颜色),叔叔变黑.

> 因为父和叔都是最远结点,调整过程没有子结点影响,也不需要旋转等额外操作,因此和LL型是完全相同的.



没有叔叔/叔叔是黑色

> 叔叔为黑色的情况下,黑结点数量不匹配,说明这种情况是上一次调整导致的(中间状态/不平衡状态);
>
> 没有叔叔的情况下,根据长度规则,此时已是最长路径(爷爷是最后一个非NIL黑结点),因此新增结点一定是最远结点,即插入后的第一次修正

左左(LL型):爷爷右单旋(降高度),交换父爷颜色

> 1. 为什么要旋转? 
>
> ​	在叔叔为空的情况下,插入红色结点可能会违反长度规则(一条路径中最长路径不超过最短路径的两倍),
>
> ![image-20240825171014847](STL%20%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%20C++%E5%AE%9E%E7%8E%B0.assets/image-20240825171014847.png)
>
> ​											(上图举例)
>
> 在上一篇AVL树中我们知道使用旋转子树可以降低高度(旋转过程在AVL树篇有详细描述,本篇不再具体描述,.同样的,红黑树在违反长度规则后也可以使用旋转来降低高度.经过验证,旋转处理可以有效解决违反长度规则问题.
>
> 
>
> 2. 如何旋转?
>
>    LL型中,对爷爷结点进行左旋,之后爷爷结点成为父结点的左孩子,高度-1;再交换父爷结点颜色,红黑树就平衡了.
>
> 3. 旋转下来后为什么要变色? 如何变色?
>
>    旋转下来,父亲结点是祖先,是红色;但是爷爷是黑色,即以父结点为根的两条路径黑结点数量不平衡,一条多一个另一条少一个,这种情况下交换父爷结点颜色即可平衡.

左右(LR型):父左单旋(转成LL型),爷爷右单旋(降高度),交换父爷颜色.





爷爷非根,在有叔叔且为红的情况下,新增结点加一轮修正后,爷爷会变红 此时如果祖爷爷也为红,需要继续修正(两种大情况)

